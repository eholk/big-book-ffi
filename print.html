<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Big Book of Rust Interop</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Fundamentals</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Kinds of interop - C lib, Rust lib, mixed program, etc.</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> Bindings</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> Error handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Building and linking</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> Tools</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Principles</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Ownership and memory management - mem::forget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Safety</div></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/layered.html"><strong aria-hidden="true">3.1.</strong> Layered library design</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">4.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/functions.html"><strong aria-hidden="true">4.1.</strong> Functions and methods</a></li><li class="chapter-item expanded "><a href="reference/numerics.html"><strong aria-hidden="true">4.2.</strong> Numeric types</a></li><li class="chapter-item expanded "><a href="reference/strings.html"><strong aria-hidden="true">4.3.</strong> Strings</a></li></ol></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">5.</strong> Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Big Book of Rust Interop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Interoperation with other languages is much easier in Rust than in most languages. However, it is often still the most difficult part of adopting Rust (especially if you need to interoperate with C++ rather than just C). Cross-language interop is often generically termed FFI (which literally means foreign function interface, but is used to mean all aspects of interop).</p>
<p>The good news is that interop is extremely low cost (interop with C is cheap and interop with other languages is no more expensive than interop with C) and the fundamentals (ABI compatibility of many datatypes and functions, extern declarations, etc.) are built in to Rust. In many cases, there is no need for data marshalling or serialization, or adaptation for calling conventions, etc. Calling a Rust function from C or vice versa is no more expensive than calling a C function in a different library (and since LTO works across the language boundary, it can even be as cheap as a within the same file).</p>
<p>Generally speaking, Rust is ABI-compatible with C. That means that Rust can interoperate with any language which can interoperate with C (though FFI with languages other than C is likely to be more complex and to have some runtime overhead). There is community support for interop with C++, Ruby, Javascript, and Python. Interop with .net and Java is supported via P/Invoke and JNI respectively.</p>
<p>There are three challenges with Rust and foreign language interop: building the project, ensuring mechanical compatibility between types and functions, and ensuring that Rust's safety invariants are upheld. All FFI calls are unsafe in Rust. To ensure correctness, invariants around ownership and uniqueness, thread safety, and panics must be ensured at the FFI boundary.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The more well-defined the boundary between Rust and foreign code, the easier things will be. At the limit, if your Rust and foreign code can live in different processes (i.e., are different programs compiled separately) and can communicate via some form of IPC then you won't have to worry about a lot of the issues with interop at all! Rust has great support for serialization/deserialization, gRPC, and other IPC/RPC technologies which can facilitate this.</p>
<p>If you need Rust and foreign code in the same process, then they should be used in separate 'components' of your design. Do not attempt to have Rust and foreign code interoperate in a fine-grained way within a single component. If you are migrating from another language to Rust, plan the migration on a per-component rather than a per-file basis. It is worth putting some up-front effort into designing the API of these components and the language boundary. As well as the usual API design issues, making the API coarse-grained (i.e., avoiding many calls), using simple datatypes (the more C-like, the better) with simple invariants, and avoiding bidirectional interaction will make FFI issues simpler.</p>
<p>Using a generic FFI option, such as COM/WinRT, is a good option if components can be separate to this extent. You will still have to consider safety issues, but the mechanical issues of corresponding types, etc., are much easier. The windows-rs crate offers good support for COM and WinRT.</p>
<p>In terms of dependencies, Rust code can be either upstream (e.g., R -&gt; C) or downstream (C -&gt; R) of foreign code (it is possible to have many layers of dependencies, e.g., C -&gt; R -&gt; C but each dependency can be considered separately). It is possible to have Rust code embedded in a foreign library and thus have a bidirectional dependency, however, you should avoid this! It is difficult to manage and build the code, and makes interop error-prone.</p>
<p>In other words, you can think of interoperating code as either exposing a Rust API to C code (or other languages which interoperate with a C ABI), or as exposing a C API to Rust code. The former is usually encountered when writing a Rust component which can be used from other languages, the latter when new Rust code must interoperate with legacy code.</p>
<h3 id="using-rust-code-from-c"><a class="header" href="#using-rust-code-from-c">Using Rust code from C</a></h3>
<p>When designing a Rust library to be used from other languages, the design depends on whether the library is only designed to be used from other languages or if it is meant to be used from Rust code too (and in this case, whether the usage from Rust or from other languages is primary). If the Rust code will only be used from other languages, then design a crate with no public items other than <code>extern</code> ones which are C-compatible. If the Rust code must be used from both Rust and other languages, then it is usually better to have a pure Rust crate and a second wrapper crate which provides the C API. If the primary consumer will be Rust code, then design the Rust crate to have a Rust-idiomatic API; the wrapper crate may need to do considerable work to project a C API. If the primary consumer will be other languages, then design the API of the Rust crate to be C-idiomatic (but expressed in Rust), and the wrapper crate can be a thin wrapper (perhaps entirely auto-generated by CBindgen).</p>
<h3 id="using-c-code-from-rust"><a class="header" href="#using-c-code-from-rust">Using C code from Rust</a></h3>
<p>When wrapping a foreign library for use in Rust, consider writing a first layer in C (especially if the legacy code is C++) with an API better suited for interacting with Rust. Then have a crate which is only bindings of C code into Rust (either hand-written or auto-generated). The next layer is a crate which only has the functionality of the foreign library (i.e., no client logic), but presented in a Rust-idiomatic way. The bindings crate will be all <code>unsafe</code>, the idiomatic crate should aim to have a 100% safe API. Clients should only use the idiomatic crate and never use the bindings crate (some advanced usages may require using the bindings in unanticipated ways, however these clients should create safe abstractions of their own rather than use the bindings directly). If following this pattern, it is common to give the idiomatic Rust crate the same name as the foreign library, and the bindings library the same name with the -sys suffix, e.g., <code>foo</code> and <code>foo-sys</code>. (On the topic of naming, it is idiomatic to always avoid using an <code>-rs</code> suffix on any Rust crate: it is nearly always obvious from context that the crate is a Rust library, so <code>-rs</code> usually adds nothing).</p>
<pre><code>------------------------
     C/C++ library          libfoo
------------------------
       C wrapper            libfoo-ffi
------------------------
 Rust bindings (unsafe)     foo-sys
------------------------
Rust wrapper (idiomatic)    foo
------------------------
      Rust users
------------------------
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>If you have a mostly Rust project with some foreign libraries, you should use Cargo. If you have a project with only a small amount of Rust, then you will probably want to use the existing build system and will need to find a way to integrate the Rust build into it. Integrating Cargo and rustc with other build systems is a big topic, and this section will only be a brief summary.</p>
<p>To build foreign libraries inside a Cargo project, the usual approach is to orchestrate the foreign builds from <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build.rs</a>. The <a href="https://crates.io/crates/cc">CC</a> crate is often used to build C/C++/ASM from a build script.</p>
<p>To build Rust code from a different build system you have several options, depending on your project's constraints. The simplest approach is to have the build system just call <code>cargo build</code>, however this means the build system treats the whole Rust build as a black box, that Cargo will need network access (or you can vendor the crates, see below), and if you have multiple Rust crates they will not share dependencies (unless they can all be built with a single Cargo invocation).</p>
<p>Another approach is to use <a href="https://doc.rust-lang.org/cargo/commands/cargo-vendor.html"><code>cargo vendor</code></a> to compute and download dependencies and keep these checked-in to version control ('vendored'). Building the Rust sub-project can be handled by the build system which will call rustc directly.</p>
<p>There are also more sophisticated, part-automated approaches available for some build systems. E.g., <a href="https://github.com/google/cargo-raze">cargo-raze</a> for Bazel or <a href="https://github.com/facebookincubator/reindeer">reindeer</a> for Buck.</p>
<p>You will probably want to build a <a href="https://doc.rust-lang.org/reference/linkage.html">cdylib</a> rather than the default rlib or dylib. That is because a cdylib uses the C ABI rather than Rust's unstable ABI. </p>
<p>It is common to end up with multiple disjoint components in each language within a single project. You probably don't want to 'split' the project by language (e.g., having a single Cargo project for all Rust code or having a high-level 'rust' directory). It is usually better to have independent builds for each component (i.e., one Cargo project for each Rust component and separate sub-projects for non-Rust components), and the main library/application build system composes the output of each sub-project.</p>
<p>As well as promoting more componentized design, this has practical benefits for Cargo feature propagation, dependency versioning, etc. However, it might make builds slower because there is less sharing of artefacts.</p>
<h2 id="bindings-and-types"><a class="header" href="#bindings-and-types">Bindings and types</a></h2>
<p>Bindings between Rust and foreign functions can either be hand-written or auto-generated. To generate bindings for C/C++ functions in Rust, use <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>. To generate bindings for Rust functions in C, use <a href="https://github.com/eqrion/cbindgen">cbindgen</a>. These tools can either be called from build.rs to create bindings on the fly, or used from the command line to generate bindings which can be adjusted and checked in to version control (the latter being a good compromise between generated and hand-written bindings).</p>
<p>Choosing hand-written or generated bindings is a trade-off. Automatically generated bindings are less work, stay up to date if the foreign code changes, and are more likely to be bug-free. Getting all the types right in bindings is sometimes subtle and tricky, and is not checked at compile time. Furthermore, some bindings can be target-dependent, so any approach which does not generate bindings with knowledge of the target platform has an increased likelihood of bugs.</p>
<p>On the other hand, hand-written bindings can sometimes be higher quality since the programmer has more knowledge of how the code is used, and binding-generating tools have limitations including around modularity (bindgen does not expect to run multiple times in a single project and therefore types which are logically the same will have multiple definitions which can lead to incompatibility).</p>
<p>We recommend using auto-generated bindings where possible. In particular, wrapping generated bindings with idiomatic Rust code is less fragile in the face of change or consistency issues than trying to write better bindings by hand.</p>
<p>Another approach if you really need custom bindings but have significant amount of code (or target-dependence) is to write your own bindings generators, either from scratch or by forking bindgen. This is more reasonable if you have some source of truth for the generated bindings other than C headers.</p>
<p>Whether bindings are hand-written or auto-generated, they must follow the same rules and idioms.</p>
<p>To call a <a href="https://doc.rust-lang.org/nomicon/ffi.html#calling-foreign-functions">foreign function from Rust</a>, it must be redeclared in a Rust module inside an <code>extern</code> block, e.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;some_c_library&quot;)]
extern {
    fn callable_from_rust();
} 
<span class="boring">}
</span></code></pre></pre>
<p>To expose a Rust function to C code, declare it using the <a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code> keyword in its signature</a>. Any extern function should use the <code>#[no_mangle]</code> attribute to prevent name mangling, e.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern fn callable_from_c() {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For primitive types (e.g., <code>long</code>, <code>double</code>) in these bindings, it is recommended to use the type aliases in the <a href="https://crates.io/crates/libc">libc</a> crate which match with C types. Libc also provides Rust versions of non-primitive types used in the C standard library; <a href="https://crates.io/crates/windows-rs">windows-rs</a> provides similar Windows-specific types.</p>
<p>Rust integers, floats, and booleans correspond with C equivalents and no conversion is required (see the aliases in libc for the correspondence between Rust and C types). Note that booleans in Rust must be either <code>0</code> or <code>1</code>, technically this is true in C/C++ too, however, it is common to use integers as booleans and to treat any non-zero value as true. You must ensure that a value is <code>0</code> or <code>1</code> before treating it as a Rust <code>bool</code>.</p>
<p>Rust raw pointers can correspond with C pointers. Use <a href="https://doc.rust-lang.org/stable/std/ffi/enum.c_void.html"><code>std::ffi::c_void</code></a> for <code>void</code> pointers. 'Opaque pointers' (where the pointee is only used in one language) can be handled trivially. If the pointee is to be accessed from multiple languages, then you must consider the pointee type for compatibility.</p>
<p>Treating objects as opaque is a common idiom for interop (and <a href="https://en.cppreference.com/w/cpp/language/pimpl">in C++</a>). For foreign types which should be opaque in Rust, you can use a struct with a single private field which is a zero-sized array (there used to be advice to use a zero-variant enum for opaque types but that is no longer recommended because it can lead to UB in some circumstances (because the compiler might assume a zero variant enum can never be created)). If you must pass an opaque struct by value, then you can make it the correct size (though this is obviously fragile). For Rust types which should be opaque in C, you can declare but not define the type. Both bindgen and cxx have built-in support for such opaque types.</p>
<p>Slices in Rust combine a pointer to data with the length of the slice into a wide pointer. These components can be passed to C for use as an array without any deep conversion. The slice must be disassembled when passed to C, and if an array is passed to Rust, then it can be re-assembled (see <a href="http://jakegoulding.com/rust-ffi-omnibus/slice_arguments/">the FFI omnibus</a> for details).</p>
<p>User-defined Rust types (structs, unions, and some enums) can be passed to foreign code and accessed there. You will need to declare structs and <a href="https://doc.rust-lang.org/reference/items/unions.html">unions</a> using <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc"><code>#[repr(C)]</code></a> (or rarely <code>#[repr(packed)]</code>), and ensure that all field types are C-compatible.</p>
<p>Only enums with no fields are C-compatible. You must specify the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#repru-repri">type of the determinant</a> and may want to specify the values of variants.</p>
<p>Other Rust types should not be passed to C, unless they will be treated completely opaquely. This includes zero-sized types, trait objects, other dynamically sized types (such as slices and strings without being adapted), tuples, and enums with fields (technically it is possible to share enums with fields which are <code>#[repr(C)]</code> but the correspondence between C and Rust types is complicated and we advise against it).</p>
<p>Consider the traits derived for types which will cross the FFI boundary (e.g., <code>Send</code>, <code>Sync</code>, <code>Copy</code>, <code>Clone</code>, <code>Default</code>, <code>Debug</code>). These can affect the semantics of the types in Rust (e.g., <code>Copy</code>), can affect how tools generate bindings, and/or affect the ways in which types must be handled in foreign code (e.g, if a type does not implement <code>Send</code> then it must not be moved between threads even in foreign code where this is not enforced by the compiler). If you're using a tool to generate bindings, the documentation for that tool should have more details.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h3>
<p>It is never OK to unwind across the FFI boundary, therefore neither Rust panics nor C++ exceptions can be used. Rust's <code>Result</code> type is an enum with fields and therefore cannot cross the FFI boundary. This all makes error handling somewhat challenging. I don't think there is a general solution, you basically just have to do whatever fits best with the C code and convert that error handling to idiomatic Rust error handling as part of the wrapping of the FFI bindings into idiomatic Rust (e.g., implement a set of functions and macros to convert a C error code into a Rust <code>Result</code>).</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>All foreign code is considered unsafe by Rust. Therefore, working with foreign code is intimately related to working with unsafe code. If you are writing code which involves FFI you should have a good understanding of unsafe code in Rust. That is a big topic! Too big to cover in depth here, but I'll try and cover some of the basics and some of the interop-specific parts. See the resources below - the <a href="https://doc.rust-lang.org/nomicon">Nomicon</a> is probably the best place to start.</p>
<p>Unsafe code does not give the programmer permission to violate Rust's safety invariants. Unsafe code <em>requires</em> the programmer to uphold those invariants rather than relying on the compiler to check them. Safety is not a local property, it is possible to do things in unsafe code which cause runtime errors in safe code. Safety is often subtle and unintuitive to reason about, see this <a href="https://www.ralfj.de/blog/2020/07/15/unused-data.html">blog post</a> for some examples. The programmer must therefore carefully consider safety for any data which passes the FFI boundary, including how it is accessed in foreign code.</p>
<p>When a function is marked <code>unsafe</code> then it's whole body is treated as unsafe code, however, there is a big difference between an <code>unsafe</code> function and a safe function with an <code>unsafe</code> block - the former is unsafe to call, the latter is safe to call. You should make a function <code>unsafe</code> if the caller must help maintain safety invariants in any way. Making a function safe (with or without internal unsafety) indicates that the library and compiler will ensure safety with no requirements on the caller.</p>
<p>Safety invariants must be enforced at the boundary between safe and unsafe code. When interoperating with foreign code that means that safety invariants must be established as part of the FFI boundary. There are several techniques for helping to ensure safety at the boundary:</p>
<ul>
<li>runtime assertions (e.g., asserting that a pointer is non-null),</li>
<li>types (both Rust and foreign types can encode information which can help ensure invariants),</li>
<li>documentation (clearly documenting safety invariants makes them easier to understand and maintain).</li>
</ul>
<p>Ultimately, we rely on invariants being upheld in foreign code which the Rust compiler cannot check. This is mostly up to the programmer, but can be helped with the above techniques.</p>
<p>Safety in the context of unsafe Rust specifically means memory safety. This can be divided into a few areas which might feel disjoint:</p>
<h3 id="uniqueness-and-mutability-invariants-around-pointers"><a class="header" href="#uniqueness-and-mutability-invariants-around-pointers">Uniqueness and mutability invariants around pointers</a></h3>
<p>Rust's key invariant for ensuring memory safety is that all values must be immutable or unique. This property can be ensured statically or dynamically, but must always be upheld. Even in foreign code, this invariant must be respected, at least as far as it is observable to Rust code. I.e., if Rust code has a reference to a value, then foreign code must not mutate that value unless it can be guaranteed that the value cannot be read by the Rust code.</p>
<h3 id="pointer-validity-invariants"><a class="header" href="#pointer-validity-invariants">Pointer validity invariants</a></h3>
<p>If a raw pointer may be dereferenced in Rust code or converted to a safe reference, then it must be <a href="https://doc.rust-lang.org/nightly/std/ptr/index.html">valid</a>. Since it is usually too late to ensure validity at the point of dereference/conversion, the validity requirement must be well-documented at all points where the pointer is passed, in particular at any FFI boundary. Some aspects of validity can be checked with assertions and the FFI boundary is usually the right place to do that.</p>
<p>Pointer validity includes:</p>
<ul>
<li>pointers must be non-null,</li>
<li>pointers must point to initialised data which has not been deallocated,</li>
<li>pointers must point to well-aligned data,</li>
<li>if the size of a value derived from the pointer's type (including any padding) is n bytes, then the pointer must point to at least n bytes from a single allocated object.</li>
</ul>
<h3 id="thread-safety-invariants"><a class="header" href="#thread-safety-invariants">Thread safety invariants</a></h3>
<p>You must ensure that data which is not <code>Send</code> is not passed between threads and data which is not <code>Sync</code> is not shared between threads, even in foreign code. Furthermore, if dealing with multi-threaded code, the uniqueness and mutability invariant will be especially difficult to uphold. Therefore, it is easiest if Rust data is always kept on a single thread in foreign code.</p>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>Stack unwinding due to Rust panics, C++ exceptions, or any other cause, must never cross the FFI boundary. On the Rust side, you can use <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> to help with this. Note that when catching panics, exceptions etc., you must ensure that no data is left in an inconsistent state. That is often impossible to achieve and aborting the thread or process is the only reasonable behaviour.</p>
<h3 id="derived-safety-invariants"><a class="header" href="#derived-safety-invariants">Derived safety invariants</a></h3>
<p>Many types have their own invariants required in order to preserve safety. These are usually not exposed to the user, except in <code>unsafe</code> functions where some requirements on the caller should be documented. All such requirements must be satisfied even if the function is called from foreign code. In addition foreign code may be able to create objects in ways which are impossible in Rust (e.g., by deserialization or casting from raw bytes). In these cases, you must ensure all invariants are properly established (this can be difficult since if these invariants are not user-facing in Rust code they may be poorly documented).</p>
<p>A good example of a 'derived' invariant is utf-8 validity. Rust strings must always be valid utf-8 and this is relied upon to ensure memory safety, even though utf-8 validity is not directly a memory safety issue. Whenever you create a Rust string, you must ensure it is valid utf-8 (see the <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">String docs</a> for details).</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h2>
<p>There are several aspects of the object lifecycle to consider: deallocating memory, calling destructors, and ensuring expected lifetimes of objects. In Rust the object lifecycle is closely tied to ownership, so we discuss these aspects in terms of ownership. The tl;dr is that keeping ownership of an object (in terms of program design, not necessarily Rust types) in the language in which it was created is usually the best strategy.</p>
<p>Independent of FFI, memory must usually be deallocated by the same allocator which allocated it. Without some rather specialist effort, the allocators used from different languages will be different. Therefore, you must deallocate memory in the same language where it was allocated. If objects are passed across the FFI boundary by pointer, and that pointer is morally borrowed, then there is no tidying-up required. If ownership is transferred, then the programmer must keep around a callback to the creating language to deallocate the memory, or pass the object back for destruction.</p>
<p>Note that destructors will not be called automatically in the foreign language. So these must be called explicitly when the object is destroyed.</p>
<p>A common pattern for this is that the foreign language has a wrapper type who's destructor handles calling the creating language's destructor explicitly and calls back into that language to deallocate memory (this pattern works to or from Rust).</p>
<p>If objects are passed by value rather than by pointer, then they must implement <code>Copy</code> in Rust. Otherwise they will be copied in the foreign language where Rust assumes they will be moved. Note that objects cannot implement both <code>Drop</code> and <code>Copy</code> so you will not need to worry about calling <code>drop</code> in this case.</p>
<p>Any object accessed from Rust (whether the object was created in Rust code or not) must abide by Rust's ownership and borrowing discipline. With regards to lifecycle events, this means that destroying a borrowed pointer must not destroy the underlying object, that an owned object must not be destroyed if there are any borrowed pointers to it (or owning pointers to it if there is multiple ownership, e.g., via <code>Rc</code>), and that an object should be fully destroyed when it goes out of scope if held by value, or when all owning pointers are destroyed if it is held by pointer. Regarding FFI, this generally requires that documentation is clear about whether raw pointers/C pointers are morally owning or borrowed (and that this is tracked through foreign code), and that the FFI boundary should not transfer ownership when there are extant borrowed pointers to the object.</p>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>Interoperating with C++ is much more complicated than interoperating with C. If you follow the advice above to only interoperate at component boundaries and you design your component APIs in a conservative, C-like way (possibly by having a C-like library wrap the C++ one), then Rust/C++ interop can be fine - it is even quite well supported by Bindgen. If you must have more fine-grained interop, then things get interesting.</p>
<p>If you can (and plain bindgen is not enough), we recommend using <a href="https://cxx.rs/">cxx</a> to generate a bridge layer and bindings between Rust and C++ code. <a href="https://github.com/google/autocxx">autocxx</a> is an extension if you prefer auto-generated bindings.</p>
<p>Quite a lot of C++ features work well across FFI, see the <a href="https://rust-lang.github.io/rust-bindgen/cpp.html">bindgen docs</a> for details. There are more links to docs on C++ interop below. It can be a bit hit and miss figuring out exactly what works and what doesn't and unfortunately some issues are not caught at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<h2 id="architectural-patterns"><a class="header" href="#architectural-patterns">Architectural patterns</a></h2>
<ul>
<li>Modular interop - a high level approach for ensuring effective interop</li>
<li><a href="patterns/layered.html">Layered library design</a> - how to structure libraries and crates for interop</li>
<li>-sys crate</li>
<li>Wrap a C library</li>
<li>Serialization</li>
<li>Cross-language ownership</li>
</ul>
<h2 id="design-patterns"><a class="header" href="#design-patterns">Design patterns</a></h2>
<ul>
<li>Foreign dtor</li>
<li>Object-based API (https://rust-unofficial.github.io/patterns/patterns/ffi/export.html)</li>
<li>Rust version of C object</li>
<li>Something about intermediate types like CString/OsString (https://rust-unofficial.github.io/patterns/idioms/ffi/accepting-strings.html, https://rust-unofficial.github.io/patterns/idioms/ffi/passing-strings.html)</li>
<li>Transparent smart pointer</li>
<li>Consolidated wrapper (https://rust-unofficial.github.io/patterns/patterns/ffi/wrappers.html)</li>
<li>Strings (how to actually use them, see strings links above, https://snacky.blog/en/string-ffi-rust.html, https://dev.to/kgrech/7-ways-to-pass-a-string-between-rust-and-c-4iebZ)
)</li>
</ul>
<h2 id="programming-idioms-and-best-practices"><a class="header" href="#programming-idioms-and-best-practices">Programming idioms and best practices</a></h2>
<ul>
<li>Representing Rust errors in C (https://rust-unofficial.github.io/patterns/idioms/ffi/errors.html)</li>
<li>Representing C errors in Rust</li>
</ul>
<h2 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-patterns</a></h2>
<ul>
<li>Disguising pointers as values (unclear, disguises unsafety)</li>
<li>Using C structs directly in Rust (back compat hazards including padding, due to different back compat between C and Rust)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layered-library-design"><a class="header" href="#layered-library-design">Layered library design</a></h1>
<p>When wrapping a foreign library for use in Rust, consider writing a first layer in C (especially if the legacy code is C++) with an API better suited for interacting with Rust. Then have a crate which is only bindings of C code into Rust (either hand-written or auto-generated). The next layer is a crate which only has the functionality of the foreign library (i.e., no client logic), but presented in a Rust-idiomatic way. The bindings crate will be all <code>unsafe</code>, the idiomatic crate should aim to have a 100% safe API. Clients should only use the idiomatic crate and never use the bindings crate (some advanced usages may require using the bindings in unanticipated ways, however these clients should create safe abstractions of their own rather than use the bindings directly).</p>
<p>If following this pattern, it is common to give the idiomatic Rust crate the same name as the foreign library, and the bindings library that name with the -sys suffix, e.g., <code>foo</code> and <code>foo-sys</code>. (On the topic of naming, it is idiomatic to always avoid using an <code>-rs</code> suffix on any Rust crate: it is nearly always obvious from context that the crate is a Rust library, so <code>-rs</code> usually adds nothing).</p>
<pre><code>------------------------
     C/C++ library          libfoo
------------------------
       C wrapper            libfoo-ffi
------------------------
 Rust bindings (unsafe)     foo-sys
------------------------
Rust wrapper (idiomatic)    foo
------------------------
      Rust users
------------------------
</code></pre>
<p>When making a Rust library available to foreign code, you can adopt a similar strategy. Here, we have an idiomatic Rust crate which can be used directly by Rust users and is idiomatic and mostly safe code. There is then a Rust wrapper which is more C-like and presents an API which is more convenient to use for FFI and includes unsafe functions which make clear the invariants callers must maintain. C bindings reflect this wrapper into the C world. This can be used directly by C code, or can there can be a C/C++ wrapper which is more idiomatic (this is much more useful for C++ rather than C, since it is possible to have an idiomatic C API with the direct bindings, but that is much harder for C++). C/C++ users (again, more likely C++) then use this wrapper library rather than the bindings.</p>
<pre><code>------------------------
 Rust crate (idiomatic)     foo
------------------------
 Rust wrapper (unsafe)      foo-ffi
------------------------
       C bindings           libfoo-ffi
------------------------
C/C++ wrapper (optional)    libfoo
------------------------
      C/C++ users
------------------------
</code></pre>
<p>There are not strong naming conventions in this direction, and the above example names are not great.</p>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p>You can use <a href="patterns/TODO">bindgen</a> to generate the bindings layer (foo-sys in the example). You can use <a href="patterns/TODO">cxx</a> to generate both the C wrapper and the bindings layer, or at least parts of both.</p>
<p>In the other direction, you can use <a href="patterns/TODO">cbindgen</a> to generate C bindings (e.g., libfoo-ffi) or <a href="patterns/TODO">cxx</a> to generate both the Rust wrapper, C bindings, and C++ wrapper (although in this case the layers are not clearly defined).</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="patterns/TODO">-sys crate</a> - separating the Rust bindings from the idiomatic Rust wrapper - a component of this pattern,</li>
<li><a href="patterns/TODO">Wrap a C library</a> - the C wrapper layer - a component of this pattern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section is designed as a reference and you probably don't want to read it end to end. It is primarily aimed at those implementing and designing tools and low-level libraries, or users who need to do unusual and/or low-level interop work. Hopefully, if you're doing common integration work you mostly won't need this level of detail.</p>
<ul>
<li><a href="reference/functions.html">Functions and Methods</a></li>
<li>statics and consts - TODO <a href="https://doc.rust-lang.org/reference/abi.html#the-used-attribute"><code>used</code> attribute</a>. Using the <code>no_mangle</code> attribute implicitly implies <code>used</code>. Use <code>extern</code> for external linkage</li>
<li>Data types (TODO cover agreement, not agreeing means UB)
<ul>
<li><a href="reference/numerics.html">Numeric types</a></li>
<li><a href="reference/strings.html">Strings</a></li>
<li><a href="reference/TODO">Pointers and arrays</a> void pointers, fat pointers, const, arrays and slices</li>
<li>structs, enums, unions</li>
<li>properties - send, sync, eq, hash, etc.</li>
<li>classes</li>
</ul>
</li>
</ul>
<h2 id="linking"><a class="header" href="#linking">Linking</a></h2>
<p>extern blocks</p>
<p><code>#[link(...)]</code> attribute</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-methods"><a class="header" href="#functions-and-methods">Functions and Methods</a></h1>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p>TODO</p>
<ul>
<li>visibility</li>
</ul>
<h4 id="extern-blocks"><a class="header" href="#extern-blocks">Extern blocks</a></h4>
<p>TODO https://doc.rust-lang.org/reference/items/external-blocks.html</p>
<p><a href="https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute">link attribute</a>
ABI
implicit unsafe
see also statics</p>
<h4 id="name"><a class="header" href="#name">Name</a></h4>
<p>The names of functions (and other items) are <a href="https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html">mangled</a> by the compiler by default. Name mangling means that the name of the symbol in the compiled binary is not the same as the name in the source code. Name mangling is not stable, and you should not rely on mangled names being the same between compiler versions.</p>
<p>Use the <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code> attribute</a> to prevent name mangling of a function's name. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>If you will call a function from foreign code by name then you must use <code>no_mangle</code> (not doing so may cause linking errors or may cause incorrect runtime behaviour). If you will only call a function via a function pointer, then you don't need to.</p>
<p>Alternatively, you can use the <a href="https://doc.rust-lang.org/reference/abi.html#the-export_name-attribute"><code>export_name</code> attribute</a> to explicitly specify the name to use for the exported symbol. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name = &quot;bar&quot;]
pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This function can be called using <code>foo</code> from Rust, and <code>bar</code> from C.</p>
<p>Likewise, by default C++ will mangle function names. This is inconsistent between platforms and compilers, so it is not advisable to use the mangled names (this can be done if absolutely necessary and tools like bindgen and cxx can help with this TODO is this true?). To prevent name mangling, define functions in an <code>extern &quot;C&quot;</code> block.</p>
<p>You can specify which section of the binary the function is placed in using the <a href="https://doc.rust-lang.org/reference/abi.html#the-link_section-attribute"><code>link_section</code> attribute</a>.</p>
<h4 id="calling-convention"><a class="header" href="#calling-convention">Calling convention</a></h4>
<p>The <a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code></a> keyword is used on function definitions to specify the <a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">calling convention</a> (aka the ABI) used to call them (and on extern blocks to define the calling convention used to call the foreign functions declared inside, see above). The syntax is <code>extern &quot;ABI&quot;</code> where <code>ABI</code> is the optional <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi">ABI identifier string</a>. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>If no ABI identifier is supplied, then <code>C</code> is used. If <code>extern</code> is not used at all, then <code>Rust</code> is used.</p>
<p>The calling convention used in the declaration and definition of functions must match. This is likely to entail a somewhat complex interaction of defaults across different platforms and languages, and attributes in different languages. If you have control of both sides of the FFI, then making both <code>extern &quot;C&quot;</code> (either explicitly or by default) is probably the easiest option. You'll need to use other options if you want to match a calling convention in a library which cannot be changed.</p>
<p>The platform independent ABI identifier strings are:</p>
<ul>
<li><code>Rust</code>: Rust's ABI; this is unstable and should not be used for FFI code,</li>
<li><code>C</code>: the default C calling convention,</li>
<li><code>system</code>: the platform default calling convention for calling 'system functions'. Usually the same as extern &quot;C&quot;, except on Win32, in which case it's &quot;stdcall&quot;.</li>
</ul>
<p>The platform-specific ABI identifier strings are:</p>
<ul>
<li><code>cdecl</code>: for x86_32 C code,</li>
<li><code>stdcall</code>: for the Win32 API on x86_32,</li>
<li><code>win64</code>: for C code on x86_64 Windows,</li>
<li><code>sysv64</code>: for C code on non-Windows x86_64,</li>
<li><code>aapcs</code>: for ARM,</li>
<li><code>fastcall</code>: corresponds to MSVC's <code>__fastcall</code> and GCC and clang's <code>__attribute__((fastcall))</code>,</li>
<li><code>vectorcall</code>: corresponds to MSVC's <code>__vectorcall</code> and clang's <code>__attribute__((vectorcall))</code>.</li>
</ul>
<p>You might also come across <code>rust-intrinsic</code>, <code>rust-call</code>, and <code>platform-intrinsic</code>. These are used by the compiler and standard library, but you shouldn't use them in user code.</p>
<p>There also exist <code>-unwind</code> versions of the ABI identifier strings, e.g., <code>C-unwind</code>. These are all <a href="https://github.com/rust-lang/rust/issues/74990">unstable</a>, see the section below on unwinding for more details.</p>
<p>TODO <code>thiscall</code> is <a href="https://github.com/rust-lang/rust/issues/42202">unstable</a>, see discussion on methods</p>
<h4 id="cc-linkage"><a class="header" href="#cc-linkage">C/C++ linkage</a></h4>
<p>C/C++ functions must have external linkage (this is the default, i.e., functions may not be marked <code>static</code>).</p>
<h4 id="signature"><a class="header" href="#signature">Signature</a></h4>
<p>The types of all arguments in the function and its return type as written in the declaration and definition must <em>agree</em>. For more on type agreement, see the sections on <a href="reference/TODO">data types</a>. The names of arguments do not need to match. In Rust declarations of foreign functions, <code>_</code> may be used instead of an argument name. No other patterns may be used in arguments. Patterns may be used instead of names in the usual way for Rust functions which are exported; the foreign declarations should use a name instead of a pattern.</p>
<p>The number of arguments in definition and declaration must match, including variadic arguments. Declarations (but not definitions) in Rust may be <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#variadic-functions">variadic</a> (to match variadic functions defined in C). E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo(format: *const u8, args: ...);
}
<span class="boring">}
</span></code></pre></pre>
<p>If a function diverges, then in Rust it should have the <code>!</code> return type. In C/C++ the function should have a 'no return' attribute (<code>__attribute__((noreturn))</code>, <code>[[noreturn]]</code>, <code>[[__noreturn__]]</code>, <code>[[_Noreturn]]</code>, etc. depending on the language, version, and compiler).</p>
<p>TODO what if sigs don't agree?</p>
<p>If the return type must be used, then the Rust function should have the <code>#[must_use]</code> attribute and the C/C++ function the <code>__attribute__((warn_unused_result))</code> attribute. TODO [[nodiscard]] on ctors. Getting this wrong will lead to missing warnings which may in turn lead to runtime errors.</p>
<h3 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h3>
<p>TODO</p>
<p>calling convention (should work)
calling variadics (just works)
see also data
unsafe</p>
<h3 id="const-functions"><a class="header" href="#const-functions">const functions</a></h3>
<p>TODO</p>
<h2 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h2>
<p>TODO</p>
<p>TODO -unwind ABIs</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>TODO</p>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>TODO</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>TODO</p>
<ul>
<li>Virtual/static dispatch</li>
<li>ctors</li>
<li>dtors</li>
<li>operator overloading</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>TODO</p>
<ul>
<li>async</li>
<li>generators</li>
<li>templates/generics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h1>
<p>For numeric types to agree across an FFI, their kind (unsigned integer, signed integer, or floating point), size, and invariants must match. The size of most C/C++ types and <code>usize</code>/<code>isize</code> in Rust can vary depending on the platform. For all numeric types, if the size matches then the alignment will also match (on a single platform).</p>
<p><a href="https://doc.rust-lang.org/stable/std/ffi/index.html">std::ffi</a> defines type aliases for common numeric types which are platform-accurate; <a href="https://crates.io/crates/libc">libc</a> defines a few more aliases for less common types. Using these aliases is usually easier than using Rust types directly.</p>
<h2 id="integers-booleans-and-characters"><a class="header" href="#integers-booleans-and-characters">Integers, booleans, and characters</a></h2>
<h3 id="rust-integers"><a class="header" href="#rust-integers">Rust integers</a></h3>
<p><code>u8</code> ... <code>u64</code> and <code>i8</code> ... <code>i64</code> are unsigned and signed respectively with the number in the type indicating the number of bits.</p>
<p><code>usize</code> and <code>isize</code> are 32 bits on 32 bit platforms and 64 bits on 64 bit platforms.</p>
<h3 id="cc-integers"><a class="header" href="#cc-integers">C/C++ integers</a></h3>
<p>A C/C++ integer is unsigned if it uses the <code>unsigned</code> keyword and signed otherwise.</p>
<p>A <code>char</code> is always 8 bits, a <code>short</code> is always 16 bits, and a <code>long long</code> is always 64 bits.</p>
<p>The size of <code>int</code> and <code>long</code> are platform dependent, see <a href="https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/mod.rs#L150">std::ffi::c_{int|long}_definition</a></p>
<h3 id="128-bit-integers"><a class="header" href="#128-bit-integers">128 bit integers</a></h3>
<p>Rust supports <code>i128</code> and <code>u128</code>. These types are mostly <a href="https://github.com/rust-lang/rust/issues/54341">not safe for FFI</a> (will lead to UB) and must be avoided. In particular, they are not compatible with C's 128bit integer types where those exist. However, they can be used on <a href="https://github.com/rust-lang/libc/pull/2719">non-Windows aarch64</a>.</p>
<h3 id="booleans"><a class="header" href="#booleans">booleans</a></h3>
<p>Rust (<code>bool</code>) and C's (strictly, C99 and later, <code>_Bool</code>) boolean types are compatible. Technically, C++'s <code>bool</code> is not guaranteed to be the same representation as C's <code>_Bool</code>, but they are on all known platforms, so it is safe to assume that Rust's <code>bool</code> is compatible with C++'s.</p>
<p>It is common to use integers to represent booleans in C programs (especially older programs or when using older toolchains). These can be converted to Rust <code>bool</code>s if the size matches and they are guaranteed to only have values <code>0</code> or <code>1</code>. (It is possible to use <code>0</code> for false and non-zero for true with C's boolean operators, however, storing any value other than <code>0</code> or <code>1</code> in a Rust <code>bool</code> is UB. You can check and convert in either Rust or C code, but in the latter case you must not use a Rust <code>bool</code> in your FFI).</p>
<h3 id="characters"><a class="header" href="#characters">characters</a></h3>
<p>Rust and C character types are incompatible.</p>
<p>C character types can be converted to or from Rust's 8 bit integer types. <code>unsigned char</code> is always <code>u8</code>, <code>signed char</code> is always <code>i8</code>. <code>char</code> may be either <code>i8</code> or <code>u8</code> depending on the platform, see <a href="https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/mod.rs#L104">std::ffi::c_char_definition</a>.</p>
<p>A Rust <code>char</code> is a 32 bit type which must be a valid <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>. It is UB to create a <code>char</code> which is not valid Unicode. You should probably avoid using <code>char</code> in FFI unless you have a custom character type with the same size and invariant in your foreign code. Otherwise it is usually better to pass numeric bytes and use helper methods on <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code>char</code></a> to create the Rust <code>char</code>.</p>
<p>TODO wchar_t</p>
<h3 id="non-zero-integers"><a class="header" href="#non-zero-integers">Non-zero integers</a></h3>
<p>There are (currently unstable) type aliases for non-zero integers in <code>core::ffi</code>. These map to the non-zero integer types in <a href="https://doc.rust-lang.org/nightly/core/num/index.html"><code>core::num</code></a> with the correct size for the C integer types. The user must maintain the non-zero invariant (whether that is a safety issue depends on how the types are used); i.e., Rust does not ensure that values with this type are in fact non-zero.</p>
<h2 id="floating-point"><a class="header" href="#floating-point">Floating point</a></h2>
<p>A C <code>float</code> is equivalent to a Rust <code>f32</code> and a C <code>double</code> is equivalent to a Rust <code>f64</code>.</p>
<h2 id="simd"><a class="header" href="#simd">SIMD</a></h2>
<p>SIMD vectors cannot be used in FFI (UB). There is an <a href="https://rust-lang.github.io/rfcs/2574-simd-ffi.html">accepted RFC</a> to address this, but it has <a href="https://github.com/rust-lang/rust/issues/63068">not been implemented</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>TODO see string patterns, pointer reference (since C strings are pointers)</p>
<h2 id="rust-c-and-c-strings"><a class="header" href="#rust-c-and-c-strings">Rust, C, and C++ strings</a></h2>
<p>There are many string types in Rust and C/C++. I'll cover them here, focussing on their representations and invariants, since that is what is most important for language interop. For correct FFI, you need to understand a string's layout in memory, whether the string is nul-terminated (and whether nul characters may be embedded within the string), and the encoding of the string (e.g., UTF-8).</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust has three classes of string types in the standard library, each of which has owned and borrowed<sup class="footnote-reference"><a href="#slices">1</a></sup> types (the latter of which is usually a dynamically sized type, see <a href="reference/TODO">the wide pointer section</a>). The owned type is called a &quot;string&quot; and the borrowed type a &quot;str&quot;. You could also use a sequence of characters or bytes as strings, or define your own custom string type (see the below section on Windows strings for some examples).</p>
<p>The standard Rust string types are <a href="https://doc.rust-lang.org/nightly/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html"><code>str</code></a>. Both are UTF-8 strings and must always be valid UTF-8. A <code>String</code> is a newtype wrapping a <code>Vec&lt;u8&gt;</code>; <code>str</code> is a built-in type and always has the same representation as a <code>[u8]</code>. This means that a <code>String</code> is a pointer (a unique, non-null pointer to a sequence of <code>u8</code>s, i.e., essentially a <code>*mut u8</code> in terms of representation), a capacity (<code>usize</code>), and length (<code>usize</code>), in that order. A <code>&amp;str</code> is a wide pointer consisting of a (non-null) pointer to a sequence of <code>u8</code>s and a length (<code>usize</code>). However, the order of the components of a wide pointer is unspecified and unstable (i.e., may change in the future).</p>
<p>Rust has the <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.CString.html"><code>std::ffi::CString</code></a> and <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.CStr.html"><code>std::ffi::CStr</code></a> types for working more easily with foreign language string types. These types are <em>not</em> directly FFI compatible with C strings. These strings must be nul-terminated, have no internal nul characters, but do not have to be valid UTF-8. Use the <code>as_ptr</code> method to get a an FFI-compatible pointer. The representation of these strings is not part of their interface.</p>
<p>Similar to <code>CString</code>/<code>CStr</code>, <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a> and <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.OsStr.html"><code>std::ffi::OsStr</code></a> are meant to make working with foreign string types easier but are <em>not</em> directly FFI compatible with foreign strings. <code>OsString</code>/<code>OsStr</code> are easily convertible to both platform-native strings and Rust strings (<code>String</code>/<code>str</code>). Neither their representation nor whether they are valid Unicode is part of their interface. On Unix platforms, <code>OsStr</code> can be cheaply interconverted with byte slices, however, these are not nul-terminated. On Windows, <code>OsStr</code> can be losslessly converted into a UTF-16 (wide) string, however, this requires copying and processing the string data; again, the output string is not nul-terminated.</p>
<div class="footnote-definition" id="slices"><sup class="footnote-definition-label">1</sup>
<p>technically, these are just dynamically sized string types and are not intrinsically borrowed (e.g., <code>Box&lt;str&gt;</code> is a valid type). However, in practice these types are nearly always used with borrowed references (e.g., <code>&amp;str</code>) to represent borrowed strings. These are often called <em>string slices</em> since they can be a slice (aka substring) of the underlying string.</p>
</div>
<h3 id="c-1"><a class="header" href="#c-1">C</a></h3>
<p>C strings are pointers to a nul-terminated sequence of <code>char</code>s. They may have either pointer or array types (which are equivalent in C). C strings to not have a specified encoding, that is a program is free to interpret a C string as ASCII, UTF-8, UTF-32, or any other encoding.</p>
<h3 id="c-2"><a class="header" href="#c-2">C++</a></h3>
<p>The C++ standard library includes the <code>string</code> type (which is actually an alias of an instantiated generic type <code>basic_string&lt;char&gt;</code>). Like the C string type it does not have a specified encoding. Its methods are all byte-oriented (i.e., have no concept of a character beyond a <code>char</code>). It is not directly compatible with C strings and its representation is not part of its interface. It is easy to get a C string with the <code>c_str</code> method, whether this is guaranteed to return a pointer to the data in the string or a copy of it depends on the version of C++. </p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows uses many different string types: <code>HSTRING</code>, <code>BSTR</code>, and the <code>PSTR</code> family of types.</p>
<p><a href="https://devblogs.microsoft.com/oldnewthing/20160615-00/?p=93675"><code>HSTRING</code></a> is primarily used with WinRT and is immutable. It is usually (but not always) reference counted. It is nul-terminated, but may also include embedded nuls (it stores a length so doesn't rely on nul-termination). It's UTF-16 encoded. Empty strings are represented as a null pointer.</p>
<p><a href="https://learn.microsoft.com/en-us/archive/blogs/ericlippert/erics-complete-guide-to-bstr-semantics"><code>BSTR</code></a> is primarily used with COM. It is a nul-terminated, mutable, UTF-16 string which may include embedded nuls. A null pointer is a valid <code>BSTR</code> and represents the empty string, though empty <code>BSTR</code>s may also be used. <code>BSTR</code>s always work in conjunction with the system allocator (<code>SysAlloc*</code>) and the length of the string is laid out in memory preceeding the data, and a nul character comes after the data in memory; neither are included in the <code>BSTR</code>'s length. A <code>BSTR</code> is a pointer and points at the first character, not the length.</p>
<p>The <code>PSTR</code> family of types are 'pointer to char's, pointing to a null-terminated sequence of characters (similar to C strings). If there is a <code>C</code> in the name it is an immutable string (otherwise its mutable), if there is a <code>W</code> then the characters are wide (two bytes per character) and the string is UTF-16 encoded. If there is no <code>W</code>, then the characters are one byte and there is no specified encoding (i.e., may be ASCII or UTF-16 or whatever; these are compatible with C strings). An <code>L</code> in the name can be ignored, e.g., <code>PCWSTR</code> and <code>LPCWSTR</code> are the same type.</p>
<p>There are Rust bindings for these types in <a href="https://docs.rs/windows/latest/windows/core/index.html">windows-rs</a> and <a href="https://docs.rs/windows/latest/windows/index.html#macros">macros</a> for creating some of these string types in Rust. The type bindings are best used only for FFI: most are newtype wrappers of raw pointers, so it is very easy to create dangling pointers and other memory safety errors when using them.</p>
<p>Windows primarily uses UTF-16. Rust does not have UTF-16 strings in its standard library (though as mentioned above, OsString can losslessly handle UTF-16). The <a href="https://docs.rs/widestring/latest/widestring/">widestring crate</a> provides types including several UTF-16 string types which can make working with Windows strings much easier.</p>
<h2 id="ffi-with-foreign-strings"><a class="header" href="#ffi-with-foreign-strings">FFI with foreign Strings</a></h2>
<p>For the actual FFI, use the Rust string type which agrees with the foreign string type (see table below). </p>
<div class="table-wrapper"><table><thead><tr><th>Foreign type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>C string <code>[const] char [const] *</code></td><td>`*{const</td></tr>
<tr><td>C++ <code>string</code></td><td><a href="https://cxx.rs/binding/cxxstring.html"><code>cxx::CxxString</code></a></td></tr>
<tr><td><code>HSTRING</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.HSTRING.html"><code>windows::core::HSTRING</code></a></td></tr>
<tr><td><code>BSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.BSTR.html"><code>windows::core::BSTR</code></a></td></tr>
<tr><td><code>PSTR</code>/<code>LPSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PSTR.html"><code>windows::core::PSTR</code></a></td></tr>
<tr><td><code>PCSTR</code>/<code>LPCSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PCSTR.html"><code>windows::core::PCSTR</code></a></td></tr>
<tr><td><code>PWSTR</code>/<code>LPWSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PWSTR.html"><code>windows::core::PWSTR</code></a></td></tr>
<tr><td><code>PCWSTR</code>/<code>LPCWSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PCWSTR.html"><code>windows::core::PCWSTR</code></a></td></tr>
</tbody></table>
</div>
<p>Creating most of these strings in Rust is usually possible via some macro or conversion function.</p>
<p>The more interesting question is when and how to convert between the FFI-specific types and more standard Rust types (and which types to use). That is out of scope for the reference, but see <a href="reference/TODO">TODO patterns</a>.</p>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory management</a></h3>
<p>The usual rules of <a href="reference/TODO">memory management with FFI</a> apply: memory must be released in the same language it was allocated, and using borrowed data is easier.</p>
<h2 id="ffi-with-rust-strings"><a class="header" href="#ffi-with-rust-strings">FFI with Rust Strings</a></h2>
<p>Passing Rust strings across FFI to foreign functions is possible, but usually extracting foreign string types in Rust is easier. If you manipulate the contents of the strings, then you must respect both the usual invariants around <a href="reference/TODO">pointers</a> and Rust's string invariants (from <a href="https://doc.rust-lang.org/nightly/std/string/struct.String.html#method.from_raw_parts"><code>String</code> docs</a>):</p>
<ul>
<li>The memory must have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</li>
<li>The <code>length</code> of the string must be less than or equal to its <code>capacity.</code></li>
<li>The <code>capacity</code> of the string must be the correct size of the allocation.</li>
<li>The first <code>length</code> bytes of the string must be valid UTF-8.</li>
</ul>
<p>Note that if you are using the string types in your Rust functions, then you must establish these invariants in the foreign code. Doing so in the Rust code is unsound.</p>
<p>To pass a Rust string to C++, you can use Cxx's bindings for <a href="https://cxx.rs/binding/string.html"><code>String</code></a> or <a href="https://cxx.rs/binding/str.html"><code>&amp;str</code></a>.</p>
<p>To pass a Rust string to C, you can use a struct with the correct layout (you could look at the standard library source code, or just use the Cxx bindings as a reference).</p>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory management</a></h3>
<p>The easiest scenario is to create a <code>String</code> in Rust, pass a borrowed <code>&amp;str</code> to foreign code and ensure that the foreign code does not store the pointer, pass it to another thread, call its destructor, or deallocate it. Then memory management just works.</p>
<p>If you must store the string in foreign code, then you must pass the owned type <code>String</code>. In this case, you must ensure the pointer remains unique and pass it back to Rust for destruction.</p>
<p>If you allocate memory for the string in foreign code, then you must not run its destructor in Rust and you must pass the string back to foreign code for destruction. The easiest way to do that is to pass <code>&amp;str</code>. If you must pass the owned type, then you must ensure that there is no copy of the pointer kept in foreign code and that the pointer is returned to foreign code for destruction. Using a custom reference counted type might be a better alternative, see <a href="reference/TODO">TODO pattern</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="tooling-1"><a class="header" href="#tooling-1">Tooling</a></h2>
<p>Bindgen is the most popular and mature tool and is maintained by the Rust project. It is used to create bindings for C code (and some C++) in Rust code. Cbindgen can be used to create C bindings to Rust code. The other tools below are for C++ interop; cxx is the current favourite tool with the community, but is not suitable for all use cases.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-bindgen">bindgen</a></li>
<li><a href="https://github.com/eqrion/cbindgen">cbindgen</a></li>
<li><a href="https://cxx.rs/">cxx</a>, <a href="https://github.com/dtolnay/cxx">repo</a></li>
<li><a href="https://github.com/google/autocxx">autocxx</a> (Google tool for 'integrating cxx with bindgen')</li>
<li><a href="https://github.com/rust-diplomat/diplomat">diplomat</a></li>
<li><a href="https://github.com/mystor/rust-cpp">rust-cpp</a> (<code>cpp!</code> macro)</li>
<li><a href="https://github.com/Dushistov/flapigen-rs">flapigen</a> (formerly Swig)</li>
<li><a href="https://github.com/pcwalton/cxx-async">cxx-async</a></li>
<li><a href="https://github.com/Gankra/abi-cafe">ABI Cafe</a> for comparing the output of compilers for ABI compatibility</li>
</ul>
<p>You may want to use COM/WinRT for inter-language interaction, the best Rust support for COM and WinRT is in <a href="https://github.com/microsoft/windows-rs/">windows-rs</a>.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon chapter</a></li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Unofficial FFI guide</a></li>
<li><a href="http://jakegoulding.com/rust-ffi-omnibus/">FFI omnibus</a></li>
<li><a href="https://firefox-source-docs.mozilla.org/writing-rust-code/ffi.html">Firefox docs for C++ interop</a></li>
<li>FFI <a href="https://rust-unofficial.github.io/patterns/idioms/ffi/intro.html">idioms</a> and <a href="https://rust-unofficial.github.io/patterns/patterns/ffi/intro.html">patterns</a></li>
<li><a href="https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability/">Chrome docs for C++ interop</a></li>
<li>FFI chapter in <a href="https://anssi-fr.github.io/rust-guide/07_ffi.html">ANSSI-FR Secure Rust Guidelines</a></li>
</ul>
<h2 id="unsafe-programming"><a class="header" href="#unsafe-programming">Unsafe programming</a></h2>
<p>Resources for learning about unsafe programming:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter</a> in The Book.</li>
<li><a href="https://doc.rust-lang.org/nomicon">Nomicon</a></li>
<li>Unsafe code guidelines
<ul>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines">rendered</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines">repo</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues">issues</a></li>
</ul>
</li>
<li><a href="https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647">Ralf's thesis</a></li>
<li><a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf">Stacked borrows paper</a></li>
<li><a href="http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf">GhostCell paper</a></li>
<li><a href="https://www.ralfj.de/blog/">Ralf's blog</a></li>
<li><a href="https://gankra.github.io/blah/papers/thesis.pdf">Gankra's thesis</a></li>
<li><a href="https://gankra.github.io/blah/#articles">Gankra's blog</a></li>
<li><a href="https://github.com/rust-lang/miri/">MIRI repo</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
